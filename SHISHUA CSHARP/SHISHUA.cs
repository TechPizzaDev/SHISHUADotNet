using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.Arm;
using System.Runtime.Intrinsics.X86;
using System.Text;
using System.Threading.Tasks;

namespace SHISHUADotNet {

	/// <summary>
	/// SHISHUA is the world's fastest (as of 2025) pRNG. It is also incredibly resilient, passing PractRand
	/// with over 32TiB of data tested. For more information on its stats, see <see href="https://github.com/espadrine/shishua"/>.
	/// <para/>
	/// This reimplementation supports supports AVX2, SSE2, and Scalar modes.
	/// It does not support the half-size implementations at this time, nor does it support ARM for lack of Neon
	/// support in C#.
	/// </summary>
	public partial class SHISHUA {

		#region Instance Implementation

		private PrngState _state;

		/// <summary>
		/// Create a new instance of <see cref="SHISHUA"/> using the provided seed.
		/// </summary>
		/// <param name="seed0">The first 64 of 256 bits needed to create a seed.</param>
		/// <param name="seed1">The second 64 of 256 bits needed to create a seed.</param>
		/// <param name="seed2">The third 64 of 256 bits needed to create a seed.</param>
		/// <param name="seed3">The fourth 64 of 256 bits needed to create a seed.</param>
		public SHISHUA(ulong seed0, ulong seed1, ulong seed2, ulong seed3) {
			// n.b. These branches are deleted when JIT kicks in, and the only code left behind is the one that applies to this platform.
			if (Avx.IsSupported && Avx2.IsSupported) {
				_state = Initialize_AVX2(seed0, seed1, seed2, seed3);
			} else if (Sse2.IsSupported) {
				_state = Initialize_SSE2(seed0, seed1, seed2, seed3);
			} else {
				_state = Initialize_Scalar(seed0, seed1, seed2, seed3);
			}
		}

		/// <summary>
		/// Generate data, and place it into the provided <paramref name="resultBuffer"/> span. Note that this span must have a length divisible by 128.
		/// </summary>
		/// <param name="resultBuffer">A result span to store a buffer of generated bytes. Its length must be divisible by 128!</param>
		/// <exception cref="ArgumentOutOfRangeException">The provided <paramref name="size"/> is less than or equal to zero.</exception>
		/// <exception cref="ArgumentException">The provided <paramref name="resultBuffer"/> does not have a length divisible by 128, or is empty.</exception>
		public void Generate(Span<byte> resultBuffer) => Generate(resultBuffer, resultBuffer.Length);

		/// <summary>
		/// Generate a specified <paramref name="size"/> of data (in bytes), and place it into the provided <paramref name="resultBuffer"/> span.
		/// Note that this span must have a length greater than or equal to <paramref name="size"/>, and <paramref name="size"/> must be divisible by 128.
		/// </summary>
		/// <param name="resultBuffer">A result span to store a buffer of generated bytes. Must be able to store the entire <paramref name="size"/>. 
		/// This may also be <see langword="null"/> to simply advance the state without storing the data.</param>
		/// <param name="size">The amount of bytes to generate. This must be divisible by 128.</param>
		/// <exception cref="ArgumentOutOfRangeException">The provided <paramref name="size"/> is less than or equal to zero.</exception>
		/// <exception cref="ArgumentException">The provided <paramref name="resultBuffer"/> cannot contain the full <paramref name="size"/> of bytes, or the <paramref name="size"/> value is not divisible by 128.</exception>
		public void Generate(Span<byte> resultBuffer, int size) {
			ArgumentOutOfRangeException.ThrowIfNegativeOrZero(size);
			if (size % 128 != 0) throw new ArgumentException($"The {nameof(size)} parameter must be divisible by 128.", nameof(size));
			if (!resultBuffer.IsEmpty && resultBuffer.Length < size) throw new ArgumentException($"The result buffer must either be empty (null/default), or must have a length greater than or equal to {nameof(size)}.", nameof(resultBuffer));
			
			// n.b. These branches are deleted when JIT kicks in, and the only code left behind is the one that applies to this platform.
			if (Avx.IsSupported && Avx2.IsSupported) {
				Generate_AVX2(ref _state, resultBuffer, size);
			} else if (Sse2.IsSupported) {
				Generate_SSE2(ref _state, resultBuffer, size);
			} else {
				Generate_Scalar(ref _state, resultBuffer, size);
			}
		}

		#endregion

		#region Static Implementation

		/// <summary>
		/// Instantiates a new <see cref="SHISHUAState"/> with the provided seed values, and then uses the most powerful
		/// available state initializer from the algorithm to prepare it for use.
		/// </summary>
		/// <param name="state">A pre-existing state. If its seeds match, it will be overwritten. Otherwise a new instance will be assigned here.</param>
		/// <param name="seed0">The first 64 of 256 bits needed to create a seed.</param>
		/// <param name="seed1">The second 64 of 256 bits needed to create a seed.</param>
		/// <param name="seed2">The third 64 of 256 bits needed to create a seed.</param>
		/// <param name="seed3">The fourth 64 of 256 bits needed to create a seed.</param>
		/// <exception cref="ArgumentNullException">The <paramref name="state"/> is a null reference.</exception>
		public static SHISHUAState StaticInit(ulong seed0, ulong seed1, ulong seed2, ulong seed3) {
			// n.b. These branches are deleted when JIT kicks in, and the only code left behind is the one that applies to this platform.
			if (Avx.IsSupported && Avx2.IsSupported) {
				return new SHISHUAState(seed0, seed1, seed2, seed3) {
					state = Initialize_AVX2(seed0, seed1, seed2, seed3)
				};
			} else if (Sse2.IsSupported) {
				return new SHISHUAState(seed0, seed1, seed2, seed3) {
					state = Initialize_SSE2(seed0, seed1, seed2, seed3)
				};
			} else {
				return new SHISHUAState(seed0, seed1, seed2, seed3) {
					state = Initialize_Scalar(seed0, seed1, seed2, seed3)
				};
			}
		}

		/// <summary>
		/// Statically generate a specified <paramref name="size"/> of data (in bytes) using the provided <paramref name="state"/>, and place the
		/// generated data into the <paramref name="resultBuffer"/> span. Note that this span must have a length greater than or equal to 
		/// <paramref name="size"/>, and <paramref name="size"/> must be divisible by 128.
		/// </summary>
		/// <param name="state">The state, created by <see cref="StaticInit"/> (failure to do so may result in poor/broken randomizer results).</param>
		/// <param name="resultBuffer">A result span to store a buffer of generated bytes. Must be able to store the entire <paramref name="size"/>. 
		/// This may also be <see langword="null"/> to simply advance the state without storing the data.</param>
		/// <param name="size">The amount of bytes to generate. This must be divisible by 128.</param>
		/// <exception cref="ArgumentOutOfRangeException">The provided <paramref name="size"/> is less than or equal to zero.</exception>
		/// <exception cref="ArgumentException">The provided <paramref name="resultBuffer"/> cannot contain the full <paramref name="size"/> of bytes, or the <paramref name="size"/> value is not divisible by 128.</exception>
		public static void StaticGenerate(ref SHISHUAState state, Span<byte> resultBuffer, int size) {
			// n.b. These branches are deleted when JIT kicks in, and the only code left behind is the one that applies to this platform.
			if (Avx.IsSupported && Avx2.IsSupported) {
				Generate_AVX2(ref state.state, resultBuffer, size);
			} else if (Sse2.IsSupported) {
				Generate_SSE2(ref state.state, resultBuffer, size);
			} else {
				Generate_Scalar(ref state.state, resultBuffer, size);
			}
		}

		#endregion



	}
}